# JVM

## 1. JVM内存查看与分析，编写内存泄露实例

## 2. JVM垃圾回收机制，何时触发MinorGC等操作

## 3. 新生代和老生代的内存回收策略

## 4. Eden和Survivor的比例分配

## 5. JVM内存分代

## 6. 深入分析了Classloader，双亲委派机制

## 7. JVM的编译优化

## 8. 对Java内存模型的理解，以及其在并发中的应用

## 9. 指令重排序，内存栅栏

## 10. JVM对final关键字的编译优化

## 11. 谈谈JVM

\(从javac编译4阶段:词法，语法语义，生成，到类加载过程:双亲委派:加载，验证，准备，解析，实例化，实例化先谈堆分区，再说JVM内存结构，然后到GC,GC算法，触发条件，晋升，YGC,CMS过程实现，可达性分析等等，把整个体系说完后面试官肯定了一句说理解得不错…\)

## 12.  老生代GC策略 – Concurrent Mark-Sweep

每次执行Minor GC之后，都会有部分生命周期较长的对象被移入老生代，一段时间之后，老生代空间也会被占满。此时就需要针对老生代空间执行GC操作，此处我们介绍Concurrent Mark-Sweep（CMS）算法。CMS算法整个流程分为6个阶段，其中部分阶段会执行 ‘stop-the-world’ 暂停，部分阶段会和应用线程一起并发执行：

1. initial-mark：这个阶段虚拟机会暂停所有正在执行的任务。这一过程虚拟机会标记所有 ‘根对象’，所谓‘根对象’，一般是指一个运行线程直接引用到的对象。虽然会暂停整个JVM，但因为’根对象’相对较少，这个过程通常很快。
2. concurrent mark：垃圾回收器会从‘根节点’开始，将所有引用到的对象都打上标记。这个阶段应用程序的线程和标记线程并发执行，因此用户并不会感到停顿。
3. concurrent precleaning：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行mark阶段新进入老年代的对象\(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代\)。
4. remark：在阶段3的基础上对查找到的对象进行重新标记，这一阶段会暂停整个JVM，但是因为阶段3已经欲检查出了所有新进入的对象，因此这个过程也会很快。
5. concurrent sweep：上述3阶段完成了引用对象的标记，此阶段会将所有没有标记的对象作为垃圾回收掉。这个阶段应用程序的线程和标记线程并发执行。
6. concurrent reset：重置CMS收集器的数据结构，等待下一次垃圾回收。

相应的，对于CMS算法，也需要关注两点：

1. ‘stop－the－world’暂停时间也很短暂，耗时较长的标记和清理都是并发执行的。
2. CMS算法在标记清理之后并没有重新压缩分配存活对象，因此整个老生代会产生很多的内存碎片。 

## 13.  CMS Failure Mode 导致GC卡顿，时间长的原因

1. Concurrent Failure  这种场景其实比较简单，假如现在系统正在执行CMS回收老生代空间，在回收的过程中新生代来了一批对象进来，不巧的是，老生代已经没有空间再容纳这些对象了。这种场景下，CMS回收器会停止继续工作，系统进入 ’stop-the-world’ 模式，并且回收算法会退化为单线程复制算法，重新分配整个堆内存的存活对象到S0中，释放所有其他空间  解决方法 ： 很容易解决，只需要让CMS回收器更早一点回收就可以避免。JVM提供了参数-XX:CMSInitiatingOccupancyFraction=N来设置CMS回收的时机，其中N表示当前老生代已使用内存占新生代总内存的比例，该值默认为68，可以将该值修改的更小使得回收更早进行。
2. Promotion Failure  假设此时设置XX:CMSInitiatingOccupancyFraction＝60，但是在已使用内存还没有达到总内存60%的时候，已经没有空间容纳从新生代迁移的对象了。oh，my god！怎么会这样？罪魁祸首就是内存碎片，上文中提到CMS算法会产生大量碎片，当碎片容量积累到一定大小之后就会造成上面的场景。这种场景下，CMS回收器一样会停止工作，进入漫长的 ’stop-the-world’ 模式。JVM也提供了参数   -XX: **UseCMSCompactAtFullCollection**  **来减少碎片的产生** ，这个参数表示会在每次CMS回收垃圾之后执行一次碎片整理，很显然，这个参数会对性能有比较大的影响，对HBase这种对延迟敏感的业务来说并不是一个完美解决方案。


## 14. 类的生命周期

[JVM类加载机制与对象的生命周期 - Nutty - 博客园](https://www.cnblogs.com/ygj0930/p/6536048.html)

  类的生命周期包括7个部分：加载——验证——准备——解析——初始化——使用——卸载
   以上5种情况最常见的是前三种：实例化对象、读写静态对象、调用静态方法、反射机制调用类、调用子类触发父类初始化

1.加载
  通过名字获取二进制字节流，内容转存到**方法区**，内存中生成class对象，作为访问入口  通过雷鸣获取二进制字节流是通过类加载器完成的  
  ![image](http://static.lovedata.net/jpg/2018/12/12/d6f11cc444cd66f9d965b2d3488f5cbe.jpg)
    
- 启动类加载器：加载系统环境变量下JAVA_HOME/lib目录下的类库。

- 扩展类加载器：加载JAVA_HOME/lib/ext目录下的类库。

- 应用程序类加载器（系统类加载器）：加载用户类路径Class_Path指定的类库。（我们可以在使用第三方插件时，把jar包添加到ClassPath后就是使用了这个加载器）

-  自定义加载器：如果需要自定义加载时的规则（比如：指定类的字节流来源、动态加载时性能优化等），可以自己实现类加载器。     

**双亲委派模型是指：当一个类加载器收到类加载请求时，不会直接加载这个类，而是把这个加载请求委派给自己父加载器去完成。如果父加载器无法加载时，子加载器才会去尝试加载。**

2. 验证
 确保class文件的二进制字节流中包含的信息符号虚拟机要求

3：准备

   为类变量（静态变量）在方法区分配内存，并设置零值。注意：这里是类变量，不是实例变量，实例变量是对象分配到堆内存时根据运行时动态生成的
   
 4：解析
 
 5：初始化
 
  真正开始执行Java程序代码，该步执行<clinit>方法根据代码赋值语句，对 类变量和其他资源  进行初始化赋值。

## 15. jvm 对象生存周期

在JVM运行空间中，对象的整个生命周期大致可以分为7个阶段：**创建阶段（Creation）、应用阶段（Using）、不可视阶段（Invisible）、不可到达阶段（Unreachable）、可收集阶段（Collected）、终结阶段（Finalized）与释放阶段（Free）**



































