# JVM

## 1. JVM内存查看与分析，编写内存泄露实例

## 2. JVM垃圾回收机制，何时触发MinorGC等操作

## 3. 新生代和老生代的内存回收策略

## 4. Eden和Survivor的比例分配

## 5. JVM内存分代

## 6. 深入分析了Classloader，双亲委派机制

## 7. JVM的编译优化

## 8. 对Java内存模型的理解，以及其在并发中的应用

## 9. 指令重排序，内存栅栏

## 10. JVM对final关键字的编译优化

## 11. 谈谈JVM

\(从javac编译4阶段:词法，语法语义，生成，到类加载过程:双亲委派:加载，验证，准备，解析，实例化，实例化先谈堆分区，再说JVM内存结构，然后到GC,GC算法，触发条件，晋升，YGC,CMS过程实现，可达性分析等等，把整个体系说完后面试官肯定了一句说理解得不错…\)

## 12.  老生代GC策略 – Concurrent Mark-Sweep

每次执行Minor GC之后，都会有部分生命周期较长的对象被移入老生代，一段时间之后，老生代空间也会被占满。此时就需要针对老生代空间执行GC操作，此处我们介绍Concurrent Mark-Sweep（CMS）算法。CMS算法整个流程分为6个阶段，其中部分阶段会执行 ‘stop-the-world’ 暂停，部分阶段会和应用线程一起并发执行：

1. initial-mark：这个阶段虚拟机会暂停所有正在执行的任务。这一过程虚拟机会标记所有 ‘根对象’，所谓‘根对象’，一般是指一个运行线程直接引用到的对象。虽然会暂停整个JVM，但因为’根对象’相对较少，这个过程通常很快。
2. concurrent mark：垃圾回收器会从‘根节点’开始，将所有引用到的对象都打上标记。这个阶段应用程序的线程和标记线程并发执行，因此用户并不会感到停顿。
3. concurrent precleaning：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行mark阶段新进入老年代的对象\(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代\)。
4. remark：在阶段3的基础上对查找到的对象进行重新标记，这一阶段会暂停整个JVM，但是因为阶段3已经欲检查出了所有新进入的对象，因此这个过程也会很快。
5. concurrent sweep：上述3阶段完成了引用对象的标记，此阶段会将所有没有标记的对象作为垃圾回收掉。这个阶段应用程序的线程和标记线程并发执行。
6. concurrent reset：重置CMS收集器的数据结构，等待下一次垃圾回收。

相应的，对于CMS算法，也需要关注两点：

1. ‘stop－the－world’暂停时间也很短暂，耗时较长的标记和清理都是并发执行的。
2. CMS算法在标记清理之后并没有重新压缩分配存活对象，因此整个老生代会产生很多的内存碎片。 

## 13.  CMS Failure Mode 导致GC卡顿，时间长的原因

1. Concurrent Failure  这种场景其实比较简单，假如现在系统正在执行CMS回收老生代空间，在回收的过程中新生代来了一批对象进来，不巧的是，老生代已经没有空间再容纳这些对象了。这种场景下，CMS回收器会停止继续工作，系统进入 ’stop-the-world’ 模式，并且回收算法会退化为单线程复制算法，重新分配整个堆内存的存活对象到S0中，释放所有其他空间  解决方法 ： 很容易解决，只需要让CMS回收器更早一点回收就可以避免。JVM提供了参数-XX:CMSInitiatingOccupancyFraction=N来设置CMS回收的时机，其中N表示当前老生代已使用内存占新生代总内存的比例，该值默认为68，可以将该值修改的更小使得回收更早进行。
2. Promotion Failure  假设此时设置XX:CMSInitiatingOccupancyFraction＝60，但是在已使用内存还没有达到总内存60%的时候，已经没有空间容纳从新生代迁移的对象了。oh，my god！怎么会这样？罪魁祸首就是内存碎片，上文中提到CMS算法会产生大量碎片，当碎片容量积累到一定大小之后就会造成上面的场景。这种场景下，CMS回收器一样会停止工作，进入漫长的 ’stop-the-world’ 模式。JVM也提供了参数   -XX: **UseCMSCompactAtFullCollection**  **来减少碎片的产生** ，这个参数表示会在每次CMS回收垃圾之后执行一次碎片整理，很显然，这个参数会对性能有比较大的影响，对HBase这种对延迟敏感的业务来说并不是一个完美解决方案。


## 14. 类的生命周期

[JVM类加载机制与对象的生命周期 - Nutty - 博客园](https://www.cnblogs.com/ygj0930/p/6536048.html)

  类的生命周期包括7个部分：加载——验证——准备——解析——初始化——使用——卸载
   以上5种情况最常见的是前三种：实例化对象、读写静态对象、调用静态方法、反射机制调用类、调用子类触发父类初始化

1.加载
  通过名字获取二进制字节流，内容转存到**方法区**，内存中生成class对象，作为访问入口  通过雷鸣获取二进制字节流是通过类加载器完成的  
  ![image](http://static.lovedata.net/jpg/2018/12/12/d6f11cc444cd66f9d965b2d3488f5cbe.jpg)
    
- 启动类加载器：加载系统环境变量下JAVA_HOME/lib目录下的类库。

- 扩展类加载器：加载JAVA_HOME/lib/ext目录下的类库。

- 应用程序类加载器（系统类加载器）：加载用户类路径Class_Path指定的类库。（我们可以在使用第三方插件时，把jar包添加到ClassPath后就是使用了这个加载器）

-  自定义加载器：如果需要自定义加载时的规则（比如：指定类的字节流来源、动态加载时性能优化等），可以自己实现类加载器。     

**双亲委派模型是指：当一个类加载器收到类加载请求时，不会直接加载这个类，而是把这个加载请求委派给自己父加载器去完成。如果父加载器无法加载时，子加载器才会去尝试加载。**

2. 验证
 确保class文件的二进制字节流中包含的信息符号虚拟机要求

3：准备

   为类变量（静态变量）在方法区分配内存，并设置零值。注意：这里是类变量，不是实例变量，实例变量是对象分配到堆内存时根据运行时动态生成的
   
 4：解析
 
 5：初始化
 
  真正开始执行Java程序代码，该步执行<clinit>方法根据代码赋值语句，对 类变量和其他资源  进行初始化赋值。


[Java 对象生命周期和类生命周期 - huangzhen0914的专栏 - CSDN博客](https://blog.csdn.net/huangzhen0914/article/details/45172597)

java类的生命周期就是指一个class文件从加载到卸载的全过程
一个java类的完整的生命周期会经历加载、连接、初始化、使用、和卸载五个阶段
![image](http://static.lovedata.net/jpg/2018/12/12/8aaf390733737d3e1a054404ed9c6e6e.jpg)

### 加载
就是找到需要加载的类并把类的信息加载到jvm的方法区中，然后在堆区中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口

### 连接
，这个阶段的主要任务就是做一些加载后的验证工作以及一些初始化前的准备工作，可以细分为三个步骤：验证、准备和解析。

1.验证
2.准备 设置初始值
3.解析 这一阶段的任务就是把常量池中的符号引用转换为直接引用 那么什么是符号引用，什么又是直接引用呢？我们来举个例子：我们要找一个人，我们现有的信息是这个人的身份证号是1234567890。只有这个信息我们显然找不到这个人，但是通过公安局的身份系统，我们输入1234567890这个号之后，就会得到它的全部信息：比如安徽省黄山市余暇村18号张三，通过这个信息我们就能找到这个人了。这里，123456790就好比是一个符号引用，而安徽省黄山市余暇村18号张三就是直接引用。在内存中也是一样，比如我们要在内存中找一个类里面的一个叫做show的方法，显然是找不到。但是在解析阶段，jvm就会把show这个名字转换为指向方法区的的一块内存地址，比如c17164，通过c17164就可以找到show这个方法具体分配在内存的哪一个区域了。这里show就是符号引用，而c17164就是直接引用。在解析阶段，jvm会将所有的类或接口名、字段名、方法名转换为具体的内存地址。

### 初始化

 如果一个类被直接引用，就会触发类的初始化。在java中，直接引用的情况有：  
 
  类的初始化过程是这样的：按照顺序自上而下运行类中的变量赋值语句和静态语句，如果有父类，则首先按照顺序运行父类中的变量赋值语句和静态语句
  
  在类的初始化阶段，只会初始化与类相关的静态赋值语句和静态语句，也就是有static关键字修饰的信息，而没有static修饰的赋值语句和执行语句在实例化对象的时候才会运行。

 - 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
 - 加载该类的ClassLoader已经被回收。
 - 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。


### 使用

### 卸载




## 15. jvm 对象生存周期

在JVM运行空间中，对象的整个生命周期大致可以分为7个阶段：**创建阶段（Creation）、应用阶段（Using）、不可视阶段（Invisible）、不可到达阶段（Unreachable）、可收集阶段（Collected）、终结阶段（Finalized）与释放阶段（Free）**


### 创建阶段

 （1）为对象分配存储空间。

（2）开始构造对象。

（3）递归调用其超类的构造方法。

（4）进行对象实例初始化与变量初始化。

（5）执行构造方法体。

###  应用阶段

当对象的创建阶段结束之后，该对象通常就会进入对象的应用阶段。这个阶段是对象得以表现自身能力的阶段。也就是说对象的应用阶段是对象整个生命周期中证明自身“**存在价值**”的时期。在对象的应用阶段，对象具备下列特征：

◆系统至少维护着对象的一个强引用（Strong Reference）；

◆所有对该对象的引用全部是强引用（除非我们显式地使用了：软引用（Soft Reference）、弱引用（Weak Reference）或虚引用（Phantom Reference））。

1．强引用   是指JVM内存管理器从根引用集合（Root Set）出发遍寻堆中所有到达对象的路径
2．软引用  只有当内存不够的时候，才回收这类内存，因此在内存足够的时候，它们通常不被回收  使Java应用可以更好地管理内存，稳定系统，防止系统内存溢出，避免系统崩溃（crash）
 3．弱引用 弱引用（Weak Reference）对象与Soft引用对象的最大不同就在于：GC在进行回收时，需要通过算法检查是否回收Soft引用对象，而对于Weak引用对象， GC总是进行回收

### 不可视阶段  本地变量超出了其可视范围
 

###  不可到达阶段  
  处于不可到达阶段的对象，在虚拟机所管理的对象引用根集合中再也找不到直接或间接的强引用
 
 
###  可收集阶段、终结阶段与释放阶段
 
（1）垃圾回收器发现该对象已经不可到达。

（2）finalize方法已经被执行。

（3）对象空间已被重用。

## 16 那些对象可以作为GC roots？

1. 虚拟机栈  中引用的对象 栈帧中的本地变量表
2. 方法区中静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中引用的对象



## 垃圾收集算法

### 标记清除 
先标记，统一回收，   
缺点：  
 - 效率问题 速度不高
 - 空间问题，产生大量不连续的内存碎片

![image](http://static.lovedata.net/jpg/2018/12/12/fafbedd2e250fb4452f065798a28a145.jpg)

### 复制算法
解决上述的不足，内存分为大小相等两块，每次使用其中一块，内存用完了，将还活着的复制到另外一块上去，然后把使用过的内存空间一次清理掉，每次整个半区内存回收。      

优点  实现简单  运行高效  
缺点  内存缩小一半，代价过高

目前商业虚拟机都是采用这种收集算法回收 **新生代的** 
![image](http://static.lovedata.net/jpg/2018/12/12/0d4764372047b410bed25b0902fe58ab.jpg)


### 标记整理

复制算法 在存活率较高的时候就需要进行较多的复制，效率偏低















